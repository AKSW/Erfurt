<?phprequire_once 'HTTPDIGConnector.php';require_once 'PowlToDigConverter.php';require_once '../../include.php';require_once 'DIG_XML_variables.php' ;require_once '../Reasoner.php' ;/********Class-1. Constructor-2. KnowledgeBaseManagement-3. Functions from ReasonerTasks********//******* example error, still needs to be caught<response xmlns="http://dl.kr.org/dig/2003/02/lang"    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://dl.kr.org/dig/2003/02/lang      http://dl-web.man.ac.uk/dig/2003/02/dig.xsd">    <error code="400" message="General Ask Error">Inconsistent KB</error></response>*******//******still TODO:top/bottom is returned in an empty array field e.g. children()equivalents($concept) not working ******/class Erfurt_Reasoning_DIG1_1_DIGReasoner implements Erfurt_Reasoning_Reasoner{var $Client;var $digvars;var $internalURI;var $model;var $debug_flag;// here muss die 	public function Erfurt_Reasoning_DIG1_1_DIGReasoner($OWLModel,$modelURI){		//global $powl;		$this->debug_flag=true;		$this->Client=new Erfurt_Reasoning_DIG1_1_HTTPDIGConnector();		$this->digvars=new Erfurt_Reasoning_DIG1_1_DIG_XML_variables();		$this->model=$OWLModel;		$this->lookupURI($this->model,$modelURI);		//$this->internalURI=$intURI;	}	public function lookupURI($OWLmodel,$modelURI){	// retrieval of the matching internal URI	// At the moment creation of a new DB for testing		$this->internalURI=$this->createKB($modelURI);		$this->loadKB($this->model);	}	public function testReasoner(){		return $this->Client->testReasoner();	}	//returns InternalURI	public function createKB ($modelURI){		$create=$this->digvars->newKB;		$xmlstr=$this->Client->execute($create,false);		$xml = new SimpleXMLElement($xmlstr);		$internalURI=$xml->kb['uri'];		//$this->loadKB($modelURI,$internalURI);		return $internalURI;	}	public function loadKB($OWLModel){		$conv=new Erfurt_Reasoning_DIG1_1_PowlToDigConverter();		$tellAll=$conv->getDIGStringForModel($OWLModel);		$this->Client->executeTells($tellAll,$this->internalURI,false);		//TODO FEHLER ABFANGEN	}	public function releaseKB ($releaseURI){		if($debug_flag)echo "RELEASE KB\n";		$release="<releaseKB \n";		$release.=$this->digvars->namespaces;		$release.=" uri=\"".$releaseURI."\" />\n";		$this->Client->execute($release,false);		//TODO FEHLER ABFANGEN	}//*Functions from ReasonerTasks*****************************	// Primitive Concept Retrieval	//(Query for a list of all named concepts, roles and individuals)	public function allConceptNames (){		if($debug_flag)echo "ALLCONCEPTNAMES\n";		$asks.="<allConceptNames id=\"1\" />\n";		$xmlstr=$this->Client->executeAsks($asks,$this->internalURI);		$xml = new SimpleXMLElement($xmlstr);		//print_r ( $xml->conceptSet->synonyms);		//$result=$xml->conceptSet;		//print_r($result);		$retArray=Array();		foreach($xml->conceptSet->synonyms as $synonym) {			//echo "<br><br><br>";			//FINDET ALLE NAMEN $synonyms->catom['name']);			$classname=$synonym->catom['name'];				//$retArray[$classname]="aaa";			//=$this->model->getClass($classname);			$retArray["$classname"]=$this->model->getClass($classname);			//echo "<br>".$classname;		}		return $retArray;		//TODO FEHLER ABFANGEN	}	public function allRoleNames (){		if($debug_flag)echo "allRoleNames\n";		$asks.="<allRoleNames id=\"1\" />\n";		$xmlstr=$this->Client->executeAsks($asks,$this->internalURI);		$xml = new SimpleXMLElement($xmlstr);		$retArray=Array();		foreach($xml->roleSet->synonyms as $synonym) {			//echo "<br><br><br>";			//FINDET ALLE NAMEN $synonyms->catom['name']);						$propname=$synonym->ratom['name'];							//$retArray[$classname]="aaa";			//=$this->model->getClass($classname);			$retArray["$propname"]=$this->model->getProperty($propname);			//echo "<br>".$propname;		}		return $retArray;						//TODO FEHLER ABFANGEN		}	public function allIndividuals (){		if($debug_flag)echo "allIndividuals\n";		$asks.="<allIndividuals id=\"1\" />\n";		$xmlstr=$this->Client->executeAsks($asks,$this->internalURI);		$xml = new SimpleXMLElement($xmlstr);		$retArray=Array();		foreach($xml->individualSet as $synonym) {			//echo "<br><br><br>";			//FINDET ALLE NAMEN $synonyms->catom['name']);			//echo $synonym;			$individualname=$synonym->individual['name'];			//echo $individualname;				//$retArray[$classname]="aaa";			//=$this->model->getClass($classname);			$retArray["$individualname"]=$this->model->getInstance($individualname);			//echo "<br>".$individual;		}		return $retArray;		//TODO FEHLER ABFANGEN		}// Satisfiability/* (Query whether concept C is satisfiable (i.e. can ever have anyinstances))*/	public function satisfiable ($concept){		if($debug_flag)echo "SATISFIABLE: $concept\n";		$asks="<satisfiable id=\"1\" >				<catom name=\"".$concept."\" />				</satisfiable> \n";		$xmlstr=$this->Client->executeAsks($asks,$this->internalURI);		$xml = new SimpleXMLElement($xmlstr);		//print_r($xml->xpath("/true[id='0']/self/name()"));		if($xml->true['id']==1)return true;		else return false;		/* this code might be used for multiple queries		not required		echo "gut";		foreach($xml->true as $true){		echo "".$true['id']."||";		}		echo "::::::";		foreach($xml->false as $true){			echo "".$true['id']."||";		}		//echo($xml->true['id']);		//print_r($xml->false['id']);		//TODO FEHLER ABFANGEN*/	}	/*Query whether C1 subsumes C2*/	public function subsumes ($concept1, $concept2){		if($debug_flag)echo "subsumes: $concept\n";		$asks="<subsumes id=\"1\" >				<catom name=\"".$concept1."\" />				<catom name=\"".$concept2."\" />				</subsumes> \n";		$xmlstr=$this->Client->executeAsks($asks,$this->internalURI);		$xml = new SimpleXMLElement($xmlstr);				//print_r($xml->xpath("/true[id='0']/self/name()"));		if($xml->true['id']==1){return true;}		else {return false;}	}	/*Query whether C1 disjoint from, C2*/	public function disjoint ($concept1, $concept2){		if($debug_flag)echo "disjoint: $concept\n";		$asks="<disjoint id=\"1\" >				<catom name=\"".$concept1."\" />				<catom name=\"".$concept2."\" />				</disjoint> \n";		$xmlstr=$this->Client->executeAsks($asks,$this->internalURI);		$xml = new SimpleXMLElement($xmlstr);		//print_r($xml->xpath("/true[id='0']/self/name()"));		if($xml->true['id']==1){return true;}		else {return false;}	}// Concept Hierarchy	/*Query for the immediate sub- or super- concepts for a given concept	(parents/children), or the closure of all super- or sub- concepts	(ancestors/descendants)*/	public function parents ($concept){		if($debug_flag)echo "parents: $concept\n";		$asks="<parents>				<catom name = \"".$concept."\"/> 				</parents>\n"; 		$xmlstr=$this->Client->executeAsks($asks,$this->internalURI);		$xml = new SimpleXMLElement($xmlstr);		$retArray=Array();		foreach($xml->conceptSet->synonyms as $synonym) {			$classname=$synonym->catom['name'];			$retArray["$classname"]=$this->model->getClass($classname);		}		return $retArray;			}	public function children ($concept){				if($debug_flag)echo "children: $concept\n";		$asks="<children>				<catom name = \"".$concept."\"/> 				</children>\n"; 		$xmlstr=$this->Client->executeAsks($asks,$this->internalURI);		$xml = new SimpleXMLElement($xmlstr);		$retArray=Array();		foreach($xml->conceptSet->synonyms as $synonym) {			$classname=$synonym->catom['name'];			$retArray["$classname"]=$this->model->getClass($classname);		}		return $retArray;	}	public function ancestors ($concept){		if($debug_flag)echo "ancestors: $concept\n";		$asks="<ancestors>				<catom name = \"".$concept."\"/> 				</ancestors>\n"; 		$xmlstr=$this->Client->executeAsks($asks,$this->internalURI);		$xml = new SimpleXMLElement($xmlstr);		$retArray=Array();		foreach($xml->conceptSet->synonyms as $synonym) {			$classname=$synonym->catom['name'];			$retArray["$classname"]=$this->model->getClass($classname);		}		return $retArray;	}	public function descendants ($concept){				if($debug_flag)echo "descendants: $concept\n";				$asks="<descendants>						<catom name = \"".$concept."\"/> 						</descendants>\n"; 		$xmlstr=$this->Client->executeAsks($asks,$this->internalURI);		$xml = new SimpleXMLElement($xmlstr);		$retArray=Array();		foreach($xml->conceptSet->synonyms as $synonym) {			$classname=$synonym->catom['name'];			$retArray["$classname"]=$this->model->getClass($classname);		}		return $retArray;	}/*Query for all of the concepts equivalent to a given concept*//*******NOT WORKING YET*/	public function equivalents($concept){						if($debug_flag)echo "equivalents: $concept\n";				$asks="<equivalents>						<catom name = \"".$concept."\"/> 						</equivalents>\n"; 		$xmlstr=$this->Client->executeAsks($asks,$this->internalURI);		$xml = new SimpleXMLElement($xmlstr);		$retArray=Array();		foreach($xml->conceptSet->synonyms as $synonym) {			$classname=$synonym->catom['name'];			$retArray["$classname"]=$this->model->getClass($classname);		}		return $retArray;	}//Role Hierarchy/*Query for the sub- and super-concepts in the role hierarchy, byanalogy with the class hierarchy*/	public function rparents ($role){		$query = "<rparents> <ratom name = \"$role\"/> </rparents>\n";		return $query;	}	public function rchildren ($role){		$query = "<rchildren> <ratom name = \"$role\"/> </rchildren>\n";		return $query;	}	public function rancestors ($role){		$query = "<rancestors> <ratom name = \"$role\"/> </rancestors>\n";		return $query;	}	public function rdescendants ($role){		$query = "<rdescendants> <ratom name = \"$role\"/> </rdescendants>\n";		return $query;	}// Individual Queries/*Query for all instances of concept C*/	public function instances ($concept){		$query = "<instances> <catom name = \"$concept\"/> </instances>\n";	}/*Query for all concepts that I belongs to*/	public function types ($individual){		$query = "<types> <individual name = \"$individual\"> </individual> </types>\n";		return $query;	}/*Test whether instance I is an instance of concept C.*/	public function instance ($individual, $concept){		$query = "<instances>  <individual name = \"$individual\"> </individual>		<catom name = \"$concept\"/> </instances>\n";		return $query;	}/*Query for all individual pairs that are members of R*/	public function relatedIndividuals ($role){		$query = "<relatedIndividuals> <ratom name = \"$role\"/> </relatedIndividuals>\n";		return $query;	}/*Query for those individuals that are related to I through R*/	public function roleFillers ($individual, $role){		$query = "<roleFillers>  <individual name = \"$individual\"> </individual>  <ratom name = \"$role\"/> </roleFillers>\n";		return $query;	}/*Query for the values of attribute A of individual I*/	public function toldValues($individual, $attribute){		$query = "<toldValues>  <individual name = \"$individual\"> </individual>  <attribute name= \"$attribute\"> </attribute>;		<catom name = \"$concept\"/> </toldValues>\n";		return $query;	}}?>