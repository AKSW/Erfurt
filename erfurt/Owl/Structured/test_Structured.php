<?phpdefine('EF_LOCATION_RAP', '../../Store/Adapter/Rap.php');include_once('../../erfurt.php');include_once('Converter.php');$erfurt = new Erfurt_App_Default(Zend_Registry::get('config'));$model=$erfurt->getStore()->getModel("http://www.co-ode.org/ontologies/pizza/2005/05/16/pizza.owl");// Tag deaktiviert HTML ausgabeecho "<xmp>\n\n";// alle Klassen in einem Array String->Erfurt_OWL_Class$Erfurt_OWL_Class_List=$model->listClasses();$Erfurt_OWL_Class_List_Keys=array_keys($Erfurt_OWL_Class_List);//converter Object initialisieren:$Converter=new Erfurt_Owl_Structured_Converter();//einige Klassennamen zum Testen//CheeseyPizza Country InterestingPizza MeatyPizza NonVegetarianPizza RealItalianPizza Spiciness SpicyPizza SpicyPizzaEquivalent SpicyTopping VegetarianPizza VegetarianPizzaEquivalent1 VegetarianPizzaEquivalent2 VegetarianTopping// einzelne Klassenobjecte werden so geholt/*$Erfurt_OWL_Class=$classes["Spiciness"];$Erfurt_OWL_Class=$classes["node82"];$Erfurt_OWL_Class=$classes["InterestingPizza"];echo $Erfurt_OWL_Class."\n\n";*///Konversion Erfurt_OWL_Class zu Structured_Class://$Structured_Class=$Converter->convertErfurtClass($Erfurt_OWL_Class);//Konversion der Axiome/*$Structured_Class_Array=$Converter->getDisjointWithClasses($Erfurt_OWL_Class);$Structured_Class_Array=$Converter->getEquivalentClasses($Erfurt_OWL_Class);$Structured_Class_Array=$Converter->getSubclassOfClasses($Erfurt_OWL_Class)*///Augabe bei einem Object:/*echo $struct->getURI()."\n";echo $Structured_Class->toManchesterSyntaxString()."\n";*///Ausgabe bei einer Liste:/*foreach ($Structured_Class_Array as $one) {	echo $one->getURI()."\n"; 	$one->toManchesterSyntaxString()."\n";}*/$axioms=array();// Ausgabe des kompletten Models:foreach ($Erfurt_OWL_Class_List as $Erfurt_OWL_Class){		//Klasse konvertieren	$Actual_Structured_Class=$Converter->convertErfurtClass($Erfurt_OWL_Class);	echo "URI:\t\t".$Actual_Structured_Class->getURI()."\n";	echo "Class:\t\t".get_class($Actual_Structured_Class)."\n";	echo "Manchester:\t".$Actual_Structured_Class->toManchesterSyntaxString()."\n\n"; 	 	 	//Axiome 	echo "Axioms\n"; 	$Structured_Class_Array=$Converter->getDisjointWithClasses($Erfurt_OWL_Class);	echo "getDisjointWithClasses in Manchester:\n";	foreach($Structured_Class_Array as $Structured_Class){		echo $Structured_Class->toManchesterSyntaxString()."\n";		}		$Structured_Class_Array=$Converter->getEquivalentClasses($Erfurt_OWL_Class);	echo "\ngetEquivalentClasses in Manchester:\n";	foreach($Structured_Class_Array as $Structured_Class){		echo $Structured_Class->toManchesterSyntaxString()."\n";		$axioms[]=new Erfurt_Owl_Structured_AxiomEquivalence($Actual_Structured_Class,$Structured_Class);		}		$Structured_Class_Array=$Converter->getSubclassOfClasses($Erfurt_OWL_Class);	echo "\ngetSubclassOfClasses in Manchester:\n";	foreach($Structured_Class_Array as $Structured_Class){		echo $Structured_Class->toManchesterSyntaxString()."\n";		}		 	echo "************************************\n\n\n";}//end outer foreach//print_r($axioms);foreach ($axioms as $a){	echo $a->toManchesterSyntaxString()."\n";}echo "</xmp>";/**// alter scheiss//echo( $list["node321"]."\n\n");//$int=$list["node321"]->listIntersectionOf();//print_r($int);//$this->model->getList(parray_shift(//$a=$list["node321"]->listPropertyValues("http://www.w3.org/2002/07/owl#intersectionOf");//return $this->model->getList(parray_shift($this->listPropertyValues("owl:intersectionOf")),'Class');//echo $list["node321"]->isBlankNode()."aa\n\n";//$a=$model->findAsMemModel(new BlankNode("node321"),"owl:intersectionOf",null);//print_r($a);//echo $struct;//echo $struct[0]->toManchesterSyntaxString();**/?>